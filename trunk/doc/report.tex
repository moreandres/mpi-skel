\documentclass[a4paper]{report}

\usepackage{graphicx}
\usepackage{float}
\usepackage{hyperref}
\usepackage[spanish]{babel}

\begin{document}

\title{
  Universidad Nacional de La Plata\\Facultad de Inform\'atica\\
  \bigskip
  Especializaci\'on en C\'omputo de Altas Prestaciones\\
  \bigskip
  Herramientas para el Soporte de An\'alisis de Rendimiento
}

\author{
  Alumno: Andr\'es More - {\tt amore@hal.famaf.unc.edu.ar}\\
  Director: Fernando Tinetti - {\tt fernando@lidi.info.unlp.edu.ar}
}

\date{Abril 2011}

\maketitle

\begin{abstract}

  Este documento describe una investigaci\'on realizada como trabajo final para
  la Especializaci\'on en C\'omputo de Altas Prestaciones dictada en la Facultad
  de Inform\'atica de la Universidad Nacional de La Plata.

  \bigskip

  El tema de investigaci\'on consiste en m\'etodos y herramientas para el soporte
  de an\'alisis de rendimiento en aplicaciones de alto rendimiento.

  \bigskip

  Luego de la introducion de terminologia y bases teoricas del analisis cuantitativo
  de rendimiento, se discute un modelo en particular de aplicacion en etapas.

  \bigskip

  Se resume la experiencia de utilizar las herramientas {\it gprof} y {\it oprofile}
  para localizar los puntos de las aplicaciones donde se deber\'ia localizar los
  esfuerzos de optimizaci\'on.

\end{abstract}

\tableofcontents

\chapter{Introducci\'on}

Este cap\'itulo introduce este trabajo. Luego de revisar la motivaci\'on del mismo,
se resume el estado actual de la investigaci\'on y se detalla el contenido restante
del informe.

\section{Motivaci\'on}

Los desarrolladores son especialistas del dominio.

\bigskip

Menos tiempo para resultados y publicaciones.

\bigskip

Optimizaci\'on artesanal.

\section{Estado Actual}

Herramientas propietarias.

\bigskip

Patrones de dise\~no.

\bigskip

Soporte en lenguajes.

\section{Organizaci\'on del Contenido}

El resto del documento explica teor\'ia de an\'alisis de rendimiento y temas
relacionados.

\chapter{An\'alisis de Rendimiento}

Este cap\'itulo describe.

\section{Definici\'on}

El rendimiento se caracteriza por la cantidad de trabajo de computo que se logra
en comparacion con la cantidad de tiempo y el uso de los recursos.

\section{M\'etricas}

instrucciones por segundo. FLOPs. rendimiento por WATT. por d\'olar.
latencia de interrupciones. Benchmarks, punto de referencia. aplicaci\'on
sint\'etica utilizada para realizar mediciones cuantitativas.

\bigskip

$ t = N * C / f $

\section{T\'ecnicas}

\section{Modelos}

\section{Taxonom\'ia}

\chapter{Herramientas}

Este cap\'itulo revisa.

\section{Taxonom\'ia}

din\'amico versus est\'atico.

tiempo de compilaci\'on.

\section{gprof}

profiling din\'amico.

se necesita compilar la aplicaci\'on con una opci\'on espec\'ifica.

se necesita ejecutar la aplicaci\'on con un conjunto de datos dado.

datos del perfil de una aplicaci\'on.

se necesita ejecutar un analizador sobre los datos acumulados.

perfil plano. una lista de las funciones ejecutadas ordenadas por la cantidad
acumulada de tiempo utilizado.

el gr\'afico de llamadas. muestra el tiempo utilizado por las funciones y sus hijos.

las funciones recursivas son manejadas de manera especial.

\subsection{perfil de ejecuci\'on}

time, cumulative seconds, self seconds, calls, self ms/call, total ms/call, name

\subsection{gr\'afico de llamadas}

index, \% time, self, children, called, name

\subsection{comportamiento}

precisi\'on estad\'istica. muestreo. incompatibilidades.

\subsection{ejemplos}

\section{oprofile}

\subsection{introduccion}

historia. resumen. caracter\'isticas. 

\subsection{procedimiento}

ejecutar el profiler. ejecutar la aplicaci\'on. generar el resumen.

no se necesita el c\'odigo.

c\'odigo anotado si hay s\'imbolos.

componentes del sistema.

contadores de performance.

costo adicional. overhead.

\subsection{contadores de rendimiento}

\subsection{ejemplos}

\chapter{Casos de Estudio}

Este cap\'itulo aplica.

\section{Multiplicaci\'on de Matrices}

La multiplicaci\'on de matrices es una operaci\'on fundamental en m\'ultiples campos
de aplicaci\'on cient\'ifica como la resoluci\'on de ecuaciones lineales y la
representaci\'on de grafos y espacios dimensionales. Por ello existe abundante
 material sobre el tema.

\bigskip

A continuaci\'on se muestra una comparaci\'on de diferentes m\'etodos, se demuestra
claramente con este ejercicio que la sofisticaci\'on de librer\'ias contra
m\'etodos artesanales de optimizaci\'on.

\bigskip

El c\'odigo fuente de una implementaci\'on simplista se encuentra adjuntado en el
ap\'endice. Al aplicar las herramientas vistas previamente se identifica claramente
que la multiplicaci\'on de los elementos de la matriz consume el mayor tiempo de
c\'omputo.

\section{Distribuci\'on de Calor en Dos Dimensiones}

\section{Reinas}

\section{Transformadas de {\it Fourier}}

\chapter{Conclusiones}

Este capitulo concluye.

\chapter{Trabajo Futuro}

Este capitulo propone.

\begin{thebibliography}{9}
  
\bibitem{mpi}
  Message Passing Interface Forum,
  \emph{MPI: A Message-Passing Interface Standard},
  2.2,
  2009.

\bibitem{openmp}
  OpenMP Architecture Review Board,
  \emph{OpenMP Application Program Interface}.
  3.0,
  2008.

\bibitem{tinetti}
  Fernando Tinetti,
  \emph{C\'omputo Paralelo en Redes Locales de Computadoras},
  2004.

\bibitem{gprof}
 Susan L. Graham,  Peter B. Kessler,  Marshall K. McKusick,
 \emph{gprof: A Call Graph Execution Profiler},
 1982.

\bibitem{oprofile}
J. Levon,
\emph{oprofile: hardware profiler for Linux systems},
{\tt http://oprofile.sourceforge.net}.

\bibitem{hennessy-patterson}
 John. L. Hennesy, David A. Patterson,
 \emph{Computer Architecture: A Quantitative Approach, 3rd Edition},
 2002.

\bibitem{intel}
 Intel Press,
 \emph{Intel64 and IA-32 Architectures Software Developer's Manual - Volume 3B: System Programming Guide, Part 2},
 March 2010.

\bibitem{what}
 Ulrich Deeper,
 \emph{What Every Programmer Should Know About Memory},
 November 2007.

\bibitem{patterns}
 G. Mattson, B.A. Sanders and B.L. Massingill, 
 \emph{Patterns for Parallel Programming, Addison-Wesley},
 2004.

\bibitem{automatic-performance-analysis}
 T. Margalef, J. Jorba, O. Morajko, A. Morajko, E. Luque,
 \emph{Different approaches to automatic performance analysis of distributed applications},
 2004.

\bibitem{capturing-performance-knowledge}
 K. Huck, O. Hernandez, V. Bui, S. Chandrasekaran, B. Chapman, A. Malony, L McInnes, B. Norris,
 \emph{Capturing performance knowledge for automated analysis},
 2008.

\bibitem{automatic-openmp-mpi-analysis}
 F. Wolf, B. Mohr,
 \emph{Automatic performance analysis of hybrid MPI/OpenMP applications},
 2003.

\bibitem{intro-software-performance}
 C. Smith,
 \emph{Introduction to software performance engineering: origins and outstanding problems},
 2007.

\bibitem{future-software-performance}
 M. Woodside, G. Franks, D. Petriu,
 \emph{The Future of Software Performance Engineering},
 2007.

\bibitem{critical-overview}
 J. Browne,
 \emph{A critical overview of computer performance evaluation},
 1976.

\bibitem{hpctoolkit}
  Rice University,
 \emph{HPC Toolkit},
 {\tt http://hpctoolkit.org}.

\bibitem{papi}
  University of Tennessee,
  \emph{Performance Application Programming Interface},
  {\tt http://icl.cs.utk.edu/papi}.

\end{thebibliography}

\end{document}
